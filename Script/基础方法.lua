
--=============================================================================--
-- @作者: 白狐剑仙。
-- @邮箱: 1733450036@qq.com
-- @创建时间:   2017-08-01 12:45:25
-- @最后修改来自: 白狐剑仙。
-- @Last Modified time: 2017-11-22 15:54:19
--=============================================================================--


--=============================================================================--
-- ■ 取整()
--=============================================================================--
function 取整(num)
     if (num >= 0) then
        return math.floor(num+.5)
     else
        return math.ceil(num-.5)
    end
end
--=============================================================================--
-- ■ 取整_()
--=============================================================================--
function 取整_(num)
     if (num >= 0) then
        return math.floor(num+.5)
     else
        return math.ceil(num-.5)
    end
end

--=============================================================================--
-- ■ 数值到格式文本()
--=============================================================================--
function 数值到格式文本(数值,是否进行千分位划分)

    local 返回值 = ""
    local 字符串 = tostring(数值)
    local 字符串长度 = string.len(字符串)

    if( 是否进行千分位划分 == true )then

        for i=1,字符串长度 do
            返回值 = string.char(string.byte(字符串,字符串长度 + 1 -i))..返回值
            if(math.mod(i,3) == 0)then
                if(字符串长度 - i ~= 0)then
                    返回值 = ","..返回值
                end
            end
        end
    else
        返回值 = string.format(数值)
    end

    return 返回值
end

--=============================================================================--
-- ■ 分割文本 ()
--=============================================================================--
function 分割文本(w,z)-- 参数:待分割的字符串,用作分割的字符
    local a = { }            --声明a
    while (true) do          --判断循环
        local pos = string.find(w,z) --取出分割的字符的位置
        if (not pos) then            --如果位置的值不为空,↓↓↓
            a [#a+1] = w             --因为取不到z的位置,把w保存到数组a中
            break
           --如果位置的值为空,跳出循环
        end
        local sub_w = string.sub(w, 1, pos - 1) --取文本中间（文本,起始位置,结束位置）,取出的文本保存到sub_w
        a[ #a + 1] = sub_w                      --把sub_w保存到数组a中
        w = string.sub(w, pos + 1, #w)         --把w当前位置到文本末所剩下的文本赋值到w中
                               --[#字符串]=为取字符串长度
    end
    return a   -- 返回:子串表.(含有空串)
end

--=============================================================================--
-- ■ 分割为字符组 ()
--=============================================================================--
function 分割为字符组(数据)
  local n = 1
  local 分割后文本 = {}
  while n <= #数据 do

    while string.byte(string.sub(数据, n, n )) > 369 do
      table.insert(分割后文本, string.sub(数据, n, n + 1))
      n = n + 2
    end
    table.insert(分割后文本, string.sub(数据, n, n ))
    n = n + 1
  end
  return 分割后文本
end
--=============================================================================--
--■ 倒找文本 ()
--=============================================================================--
function 倒找文本(字符串,字符)--待查的字符串,欲查的字符
    local 位置 = { }
    for i=1, string.len(字符串) do
        local a , b = string.find (字符串, 字符,i)  --参数1:待查的字符串,欲查的字符 返回开始位置,结束位置
        if a~=nil and 位置[#位置]~=a then
            位置[#位置+1] = a
        end
    end
    return 位置[#位置]
end
--=============================================================================--
--■ 删首尾空 ()
--=============================================================================--
function 删首尾空(w) --删除字符串前后的空格
     if type(s) ~= "string" then
        s = tostring(s)
    end
    return string.gsub(s, "^%s*(.-)%s*$", "%1")
    --return (string.gsub(w, "^%s*(.-)%s*$", "%1"))
end

--=============================================================================--
--■ 读入文件 ()
--=============================================================================--
function 读入文件(路径)-- 参数1:文件路径       [[D:\图片\2.txt]]
    local a = io.open(路径)--打开指定文件
    local b = a:read("*a")--读入文件所有字串符 *a ,保存到B中
    return a:close() and b  --关闭文件 且 返回B中的字串符
end

--=============================================================================--
--■ 取画面坐标 ()
--=============================================================================--
function 取画面坐标(参照点x,参照点y,地图宽,地图高,屏幕宽,屏幕高)
    local 偏移x = 0
    local 偏移y = 0

    if(参照点x > 屏幕宽 / 2 and 参照点x < 地图宽 - 屏幕宽 / 2)then
        偏移x = -(参照点x - 屏幕宽 / 2)
        参照点x = 屏幕宽 / 2
    elseif(参照点x <= 屏幕宽 / 2)then
        偏移x = 0
    elseif(参照点x >= 地图宽 - 屏幕宽 / 2)then
        偏移x = -(地图宽 - 屏幕宽)
    end

    if(参照点y > 屏幕高 / 2 and 参照点y < 地图高 - 屏幕高 / 2)then
        偏移y = -(参照点y - 屏幕高 / 2)
        参照点y = 屏幕高 / 2
    elseif(参照点y <= 屏幕高 / 2)then
        偏移y = 0
    elseif(参照点y >= 地图高 - 屏幕高 / 2)then
        偏移y = -(地图高 - 屏幕高)
    end
    return 偏移x,偏移y
end

--=============================================================================--
--■ 文字_描边显示 ()
--=============================================================================--
function 文字_描边显示(_文字,x,y,内容,文字颜色,描边颜色)

            _文字:置颜色(描边颜色)
            _文字:显示(x-1,y,内容)
            _文字:显示(x+1,y,内容)
            _文字:显示(x,y-1,内容)
            _文字:显示(x,y+1,内容)
            _文字:置颜色(文字颜色)
            _文字:显示(x,y,内容)
--文字_描边显示(文字,self.坐标.x -self.顶部显示宽度/2 + Q_画面偏移.x ,self.坐标.y - self.顶部显示偏移 + Q_画面偏移.y,self.顶部显示,白,黑)
end
--=============================================================================--
--■ 取运行目录 ()
--=============================================================================--
function 取运行目录()

    require("lfs")
    path=lfs.currentdir()

    return path
end

--=============================================================================--
-- ■ __包围盒碰撞检测()
--=============================================================================--
function __包围盒碰撞检测(包围盒A,包围盒B)

    local 返回值 = 包围盒A:检查盒(包围盒B)

    return 返回值
end

--=============================================================================--
--■ 复制表 ()
--=============================================================================--
function 复制表(object)

    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end
        local new_table = {}
        lookup_table[object] = new_table
        for index, value in pairs(object) do
            new_table[_copy(index)] = _copy(value)
        end
        return setmetatable(new_table, getmetatable(object))
    end

    return _copy(object)
end